{"title":"C. Matrix Sorting","contestId":"1500","contestName":"Codeforces Round #707 (Div. 1, based on Moscow Open Olympiad in Informatics)","problemIndex":"C","timeLimit":"2 seconds","memLimit":"256 megabytes","inputFormat":"standard input","outputFormat":"standard output","problemHtml":"<p>You are given two tables $$$A$$$ and $$$B$$$ of size $$$n \\times m$$$. </p><p>We define a <span class=\"tex-font-style-it\">sorting by column</span> as the following: we choose a column and reorder the rows of the table by the value in this column, from the rows with the smallest value to the rows with the largest. In case there are two or more rows with equal value in this column, their relative order does not change (such sorting algorithms are called <span class=\"tex-font-style-it\">stable</span>).</p><p>You can find this behavior of sorting by column in many office software for managing spreadsheets. Petya works in one, and he has a table $$$A$$$ opened right now. He wants to perform zero of more sortings by column to transform this table to table $$$B$$$.</p><p>Determine if it is possible to do so, and if yes, find a sequence of columns to sort by. Note that you <span class=\"tex-font-style-bf\">do not need</span> to minimize the number of sortings.</p>","inSpecsHtml":"<div class=\"section-title\">Input</div><p>The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 1500$$$)&nbsp;— the sizes of the tables.</p><p>Each of the next $$$n$$$ lines contains $$$m$$$ integers $$$a_{i,j}$$$ ($$$1 \\le a_{i, j} \\le n$$$), denoting the elements of the table $$$A$$$.</p><p>Each of the next $$$n$$$ lines contains $$$m$$$ integers $$$b_{i, j}$$$ ($$$1 \\le b_{i, j} \\le n$$$), denoting the elements of the table $$$B$$$.</p>","outSpecsHtml":"<div class=\"section-title\">Output</div><p>If it is not possible to transform $$$A$$$ into $$$B$$$, print $$$-1$$$.</p><p>Otherwise, first print an integer $$$k$$$ ($$$0 \\le k \\le 5000$$$)&nbsp;— the number of sortings in your solution.</p><p>Then print $$$k$$$ integers $$$c_1, \\ldots, c_k$$$ ($$$1 \\le c_i \\le m$$$)&nbsp;— the columns, by which Petya needs to perform a sorting.</p><p>We can show that if a solution exists, there is one in no more than $$$5000$$$ sortings.</p>","noteHtml":"<div class=\"section-title\">Note</div><p>Consider the second example. After the sorting by the first column the table becomes</p><p>$$$$$$\\begin{matrix} 1&amp;3&amp;3\\\\ 1&amp;1&amp;2\\\\ 2&amp;3&amp;2. \\end{matrix}$$$$$$</p><p>After the sorting by the second column the table becomes</p><p>$$$$$$\\begin{matrix} 1&amp;1&amp;2\\\\ 1&amp;3&amp;3\\\\ 2&amp;3&amp;2, \\end{matrix}$$$$$$</p><p>and this is what we need.</p><p>In the third test any sorting does not change anything, because the columns are already sorted.</p>","sampleTestcases":[{"id":1615742471914,"input":"2 2\n2 2\n1 2\n1 2\n2 2\n","output":"1\n1"},{"id":1615742471915,"input":"3 3\n2 3 2\n1 3 3\n1 1 2\n1 1 2\n1 3 3\n2 3 2\n","output":"2\n1 2"},{"id":1615742471916,"input":"2 2\n1 1\n2 1\n2 1\n1 1\n","output":"-1"},{"id":1615742471917,"input":"4 1\n2\n2\n2\n1\n1\n2\n2\n2\n","output":"1\n1 \n"}],"submitUrl":"https://codeforces.com/contest/1500/submit","language":"c++","editorial":"<div><p>Let's first learn how to solve with O ($$$n \\cdot m^2$$$).</p><p>Note that each column can be sorted no more than once.</p><p>Now, let's note that if we could turn matrix A into matrix B, then B has a sorted column.</p><p>Idea &nbsp;— we will choose the rows that we will sort from the end. To do this, we can support string equivalence classes. Where and why? If two rows are in the same class, then the columns that we applied had the same values. Then, we need to find a column that does not break the sequence between the rows inside each of the classes. Let's iterate through such a column every time. We don't care if we apply someone extra &nbsp;— because of the condition of the possibility of application, it will definitely not spoil. Then just apply the column if we could. Each time, the number of equivalence classes does not decrease, so the number of columns that can be applied does not decrease. If it was not possible to sort after all the applications, it means that some of the classes could not be split correctly, which means that it is impossible to get matrix B from matrix A.</p><p>Let's learn how to solve it faster than in a cube. Let's not store equivalence classes explicitly. To do this, note that in the final state of B, the equivalence classes are sub-arrays! Then it is enough for us to store for each pair of adjacent rows whether we were able to separate them (swap the lower and upper places) &nbsp;— let's call it $$$cut$$$. Also, for each column, we will store the number of still unresolved inversions in it, call it $$$cnt$$$. Initially, &nbsp;— is just the number of inversions in the column. Next, it will be the same number of inversions, but only within the classes. How does this solution differ from a cube? We are able to quickly find which column can be applied - this is the column $$$j$$$ for which $$$cnt[j] = 0$$$. Then we just need to learn how to update the cnt. Let's start a queue (we can say that this is bfs, but in fact we do not use anything other than a queue from bfs), to which we will add only columns $$$j$$$ in which $$$cnt[j] = 0$$$, apply sorting by column, update cnt and add new columns that have $$$cnt=0$$$. $$$cut$$$will help us with this. Let's, if we managed to swap the columns (that is, in the current column $$$v$$$, $$$b[i][v] &lt; b[i - 1][v]$$$), set $$$cut[i] = 1$$$ and update all the values of $$$cnt$$$ through this row. It is clear that it does not make sense to split rows twice. Since we will apply each column at most once, and the pairs of adjacent rows are $$$O(n)$$$, the time complexity is $$$O (n \\cdot m)$$$. Do not forget that it is not necessary to divide into exactly $$$n$$$ equivalence classes, because a smaller number may be enough. So in the end, check transformations(not difficult, but need to be careful).</p><p>There is also a solution with time complexity $$$O(nm log)$$$, but I think, it is more difficult both in terms of understanding and implementation.</p></div>"}