{"title":"F. Chainword","contestId":"1511","contestName":"Educational Codeforces Round 107 (Rated for Div. 2)","problemIndex":"F","timeLimit":"3 seconds","memLimit":"256 megabytes","inputFormat":"standard input","outputFormat":"standard output","problemHtml":"<p>A chainword is a special type of crossword. As most of the crosswords do, it has cells that you put the letters in and some sort of hints to what these letters should be.</p><p>The letter cells in a chainword are put in a single row. We will consider chainwords of length $$$m$$$ in this task.</p><p>A hint to a chainword is a sequence of segments such that the segments don't intersect with each other and cover all $$$m$$$ letter cells. Each segment contains a description of the word in the corresponding cells.</p><p>The twist is that there are actually two hints: one sequence is the row above the letter cells and the other sequence is the row below the letter cells. When the sequences are different, they provide a way to resolve the ambiguity in the answers.</p><p>You are provided with a dictionary of $$$n$$$ words, each word consists of lowercase Latin letters. All words are pairwise distinct.</p><p>An instance of a chainword is the following triple: </p><ul> <li> a string of $$$m$$$ lowercase Latin letters; </li><li> the first hint: a sequence of segments such that the letters that correspond to each segment spell a word from the dictionary; </li><li> the second hint: another sequence of segments such that the letters that correspond to each segment spell a word from the dictionary. </li></ul><p>Note that the sequences of segments don't necessarily have to be distinct.</p><p>Two instances of chainwords are considered different if they have different strings, different first hints <span class=\"tex-font-style-bf\">or</span> different second hints.</p><p>Count the number of different instances of chainwords. Since the number might be pretty large, output it modulo $$$998\\,244\\,353$$$.</p>","inSpecsHtml":"<div class=\"section-title\">Input</div><p>The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 8$$$, $$$1 \\le m \\le 10^9$$$)&nbsp;— the number of words in the dictionary and the number of letter cells.</p><p>Each of the next $$$n$$$ lines contains a word&nbsp;— a non-empty string of no more than $$$5$$$ lowercase Latin letters. All words are pairwise distinct. </p>","outSpecsHtml":"<div class=\"section-title\">Output</div><p>Print a single integer&nbsp;— the number of different instances of chainwords of length $$$m$$$ for the given dictionary modulo $$$998\\,244\\,353$$$.</p>","noteHtml":"<div class=\"section-title\">Note</div><p>Here are all the instances of the valid chainwords for the first example: </p><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/734575fe874c64a4857f821627aa6847ee50e306.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"> </center><p>The red lines above the letters denote the segments of the first hint, the blue lines below the letters denote the segments of the second hint.</p><p>In the second example the possible strings are: \"<span class=\"tex-font-style-tt\">abab</span>\", \"<span class=\"tex-font-style-tt\">abcd</span>\", \"<span class=\"tex-font-style-tt\">cdab</span>\" and \"<span class=\"tex-font-style-tt\">cdcd</span>\". All the hints are segments that cover the first two letters and the last two letters.</p>","sampleTestcases":[{"id":1618653141826,"input":"3 5\nababa\nab\na","output":"11\n","result":{"id":1618653141826,"stdout":"11\n","stderr":"","exitcode":0,"signal":null,"time":114,"timeout":false}},{"id":1618653141827,"input":"2 4\nab\ncd","output":"4\n","result":{"id":1618653141827,"stdout":"4\n","stderr":"","exitcode":0,"signal":null,"time":95,"timeout":false}},{"id":1618653141828,"input":"5 100\na\naa\naaa\naaaa\naaaaa","output":"142528942\n","result":{"id":1618653141828,"stdout":"142528942\n","stderr":"","exitcode":0,"signal":null,"time":114,"timeout":false}},{"id":1618851955409,"input":"2 3\na\naa","output":"9","result":{"id":1618851955409,"stdout":"9\n","stderr":"","exitcode":0,"signal":null,"time":109,"timeout":false}},{"id":1618859174643,"input":"8 3\r\nba\r\nbbb\r\nbb\r\naba\r\naab\r\nbaa\r\nb\r\na","output":"56","result":{"id":1618859174643,"stdout":"56\n","stderr":"","exitcode":0,"signal":null,"time":152,"timeout":false}}],"submitUrl":"https://codeforces.com/contest/1511/submit","language":"c++","editorial":"<div><p>Let's use a trie to store the given words. Now let's imagine a procedure that checks if some string of length $$$m$$$ can be represented as a concatenation of some of these words. If the words were prefix-independent&nbsp;— no word was a prefix of another word, that task would be solvable with a greedy algorithm.</p><p>We could iterate over a string and maintain the current vertex of the trie we are in. Append a current letter. If there is no such transition in a trie, it can't be represented. If the vertex we go to is a terminal, jump to the root of the trie. Otherwise, just go to that vertex. </p><p>However, since the words aren't prefix-independent, we have a terminal on a path to other terminals. Thus, we can't immediately decide if we should jump to the root or just go.</p><p>Let's handle this with dynamic programming. $$$dp[i][v]$$$&nbsp;— can we put $$$i$$$ letters in such a way that the vertex of a trie we are in is $$$v$$$.</p><p>Is building a chainword letter by letter that different from this process? Apparently, it isn't. Consider $$$dp[i][v][u]$$$&nbsp;— how many ways are there to put $$$i$$$ letters in a string so that the first hint is in a vertex $$$v$$$ and the second hint is in a vertex $$$u$$$. For the transition we can try all $$$26$$$ letters to put and jump to the corresponding vertices.</p><p>That obviously, is too slow. The intuition tells us that this dp should be calculated with some kind of matrix exponentiation (since $$$m \\le 10^9$$$). That dp can be rewritten as a matrix pretty easily. However, its size is up to $$$1681 \\times 1681$$$ (the maximum number of vertices in a trie squared).</p><p>Some say that there is a way to compute the $$$m$$$-th power of such a huge matrix fast enough with Berlekamp–Massey, but I unfortunately am not familiar with it.</p><p>Thus, we'll have to reduce the size of our matrix. First, notice that the only reachable states $$$(v, u)$$$ are such that the word that is written on a path from the root to $$$v$$$ is a suffix of a word that is written on a path from the root to $$$u$$$ or vice versa.</p><p>Look at it the other way: if we build a trie on the reversed words, then one of the vertices will be an ancestor of another one. Now it's easy to estimate the number of states as the sum of depths of all vertices. However, since we look at ordered pairs of $$$(v, u)$$$, we should more or less double that amount. That should be $$$241$$$ states at max.</p><p>This can probably pass with an optimal enough implementation. We can do better, though. Let's merge the states $$$(v, u)$$$ and $$$(u, v)$$$ into one state. The intuition is basically that you can swap the hints at will. That makes the pairs unordered: now there are up to $$$161$$$ pairs. That surely will work fast enough.</p><p>The way to generate all the possible states is the following: run a dfs/bfs, starting from $$$(0, 0)$$$ that makes all valid transition and record all the states that can be visited.</p><p>While preparing the tests, I only managed to get up to $$$102$$$ states and I would really love to hear an approach to either prove a tighter bound or to generate a test closer to the bound of $$$161$$$.</p></div>","langId":"54"}