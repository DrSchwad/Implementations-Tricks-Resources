{"title":"D. Cleaning","contestId":"1474","contestName":"Codeforces Round #696 (Div. 2)","problemIndex":"D","timeLimit":"2 seconds","memLimit":"256 megabytes","inputFormat":"standard input","outputFormat":"standard output","problemHtml":"<p>During cleaning the coast, Alice found $$$n$$$ piles of stones. The $$$i$$$-th pile has $$$a_i$$$ stones.</p><p>Piles $$$i$$$ and $$$i + 1$$$ are neighbouring for all $$$1 \\leq i \\leq n - 1$$$. If pile $$$i$$$ becomes empty, piles $$$i - 1$$$ and $$$i + 1$$$ <span class=\"tex-font-style-bf\">doesn't</span> become neighbouring.</p><p>Alice is too lazy to remove these stones, so she asked you to take this duty. She allowed you to do only the following operation: </p><ul> <li> Select two <span class=\"tex-font-style-bf\">neighboring</span> piles and, if both of them are not empty, remove one stone from each of them. </li></ul><p></p><p>Alice understands that sometimes it's impossible to remove all stones with the given operation, so she allowed you to use the following superability: </p><ul> <li> Before the start of cleaning, you can select two <span class=\"tex-font-style-bf\">neighboring</span> piles and swap them. </li></ul><p></p><p>Determine, if it is possible to remove all stones using the superability <span class=\"tex-font-style-bf\">not more than once</span>.</p>","inSpecsHtml":"<div class=\"section-title\">Input</div><p>The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$)&nbsp;— the number of test cases.</p><p>The first line of each test case contains the single integer $$$n$$$ ($$$2 \\leq n \\leq 2 \\cdot 10^5$$$)&nbsp;— the number of piles.</p><p>The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$)&nbsp;— the number of stones in each pile.</p><p>It is guaranteed that the total sum of $$$n$$$ over all test cases doesn't exceed $$$2 \\cdot 10^5$$$.</p>","outSpecsHtml":"<div class=\"section-title\">Output</div><p>For each test case, print <span class=\"tex-font-style-tt\">YES</span> or <span class=\"tex-font-style-tt\">NO</span>&nbsp;— is it possible to remove all stones using the superability <span class=\"tex-font-style-bf\">not more than once</span> or not.</p>","noteHtml":"<div class=\"section-title\">Note</div><p>In the first test case, you can remove all stones without using a superability: $$$[1, 2, 1] \\rightarrow [1, 1, 0] \\rightarrow [0, 0, 0]$$$.</p><p>In the second test case, you can apply superability to the second and the third piles and then act like in the first testcase.</p><p>In the third test case, you can apply superability to the fourth and the fifth piles, thus getting $$$a = [2, 2, 2, 3, 1]$$$.</p><p>In the fourth test case, you can apply superability to the first and the second piles, thus getting $$$a = [1900, 2100, 1600, 3000, 1600]$$$.</p>","sampleTestcases":[{"id":1615657208325,"input":"5\n3\n1 2 1\n3\n1 1 2\n5\n2 2 2 1 3\n5\n2100 1900 1600 3000 1600\n2\n2443 2445","output":"YES\nYES\nYES\nYES\nNO\n","result":{"id":1615657208325,"stdout":"YES\nYES\nYES\nYES\nNO\n","stderr":"","exitcode":0,"signal":null,"time":108,"timeout":false}},{"id":1615710007872,"input":"1\n5\n2 2 2 1 3","output":"YES","result":{"id":1615710007872,"stdout":"YES\n","stderr":"","exitcode":0,"signal":null,"time":106,"timeout":false}}],"submitUrl":"https://codeforces.com/contest/1474/submit","language":"c++","langId":"54","editorial":"<div><p>Hint $$$1$$$: How to solve the promblem if we are not allowed to use a superabilty (in linear time)? </p><p>Hint $$$2$$$: Look at the first pile. There is only one way to remove stone from the first pile.</p><p>Hint $$$3$$$: If you swap $$$i$$$-th and $$$(i + 1)$$$-th piles of stones, nothing changes in way you remove stones from $$$1$$$-st, $$$2$$$-nd, $$$\\ldots$$$, $$$(i - 2)$$$-th piles.</p><p>Hint $$$4$$$: Look at the problem from the both sides: from the beginning of $$$a$$$ and from the end of $$$a$$$.</p><p>Solution:</p><p>We can check, whether we can remove all stones without a supeability using the following algorithm:</p><p></p><ul></ul><p></p><p></p><li> How can we remove the stones from the $$$1$$$-st pile? Only with stones from the second pile! If $$$a_1 &gt; a_2$$$, then we can't remove all stones from the $$$1$$$-st pile.</li><p></p><p></p><li> Now we have $$$0$$$ stones in the $$$1$$$-st pile and $$$a_2 - a_1$$$ stones in the $$$2$$$-nd pile. We can apply the idea above and get that we should have $$$a_2 - a_1$$$ stones in the $$$3$$$-rd pile.</li><p></p><p>...</p><p></p><li> In the end we have only $$$1$$$ pile. If there are any stones in it, we can't remove all stones. Otherwise, we constructed a solution for removing all stones. </li><p></p><p>Also, we profed that there can be only one way to remove all stones.</p><p>Now we have to improve this algorithm. Let $$$p_i$$$ be a number of stones in the $$$i$$$-th pile after cleaning piles $$$1$$$, $$$2$$$, ..., $$$i-1$$$ using this algorithm (and $$$(i+1)$$$-th, $$$(i+2)$$$-th, ..., $$$n$$$-th piles have the initial amount of stones). Now, let $$$s_i$$$ be a number of stones in the $$$i$$$-th pile, if we removed all stones from the $$$(i+1)$$$-th, ..., $$$n$$$-th piles (using the same algorithm, but we do operations in reversed order).</p><p>We compute all $$$p_i$$$ and all $$$s_i$$$ in $$$\\mathcal{O}(n)$$$. Now, if we try to swap $$$i$$$-th and $$$(i+1)$$$-th piles, we should check, that we can remove stones from four piles: $$$p_{i-1}$$$, $$$a_{i + 1}$$$, $$$a_{i}$$$, $$$s_{i+2}$$$. If we can do this for any $$$i$$$, answer is <span class=\"tex-font-style-tt\">YES</span>.</p></div>"}